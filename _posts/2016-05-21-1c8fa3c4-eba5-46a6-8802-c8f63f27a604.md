---
layout: post
title:  面向对象
date:   2016-05-21
categories: Python
tags:  Python Java
---

* content
{:toc}


对面向对象其实非常的不了解。







[Crossin编程教室](http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5MDEyMDk4Mw==&appmsgid=10000196&itemidx=1&sign=2176872b0086314a9463ccc811731cc4)

## 面向对象思想

>按照功能需求的顺序来设计程序。这种被称为“面向过程”的编程。
还有一种程序设计的方法，把数据和对数据的操作用一种叫做“对象”的东西包裹起来。这种被成为“面向对象”的编程。这种方法更适合较大型的程序开发。

>面向对象编程最主要的两个概念就是：类（class）和对象（object）

>类是一种抽象的类型，而对象是这种类型的实例。

>举个现实的例子：
“笔”作为一个抽象的概念，可以被看成是一个类。而一支实实在在的笔，则是“笔”这种类型的对象。

>一个类可以有属于它的函数，这种函数被称为类的“方法”。
一个类/对象可以有属于它的变量，这种变量被称作“域”。
域根据所属不同，又分别被称作“类变量”和“实例变量”。

>继续笔的例子。一个笔有书写的功能，所以“书写”就是笔这个类的一种方法。
每支笔有自己的颜色，“颜色”就是某支笔的域，也是这支笔的实例变量。

>而关于“类变量”，我们假设有一种限量版钢笔，我们为这种笔创建一种类。而这种笔的“产量”就可以看做这种笔的类变量。因为这个域不属于某一支笔，而是这种类型的笔的共有属性。

>域和方法被合称为类的属性。

>python是一种高度面向对象的语言，它其中的所有东西其实都是对象。所以我们之前也一直在使用着对象。看如下的例子：

>s = 'how are you'
>\#s被赋值后就是一个字符串类型的对象
>l = s.split()
>\#split是字符串的方法，这个方法返回一个list类型的对象
>\#l是一个list类型的对象

>通过dir()方法可以查看一个类/变量的所有属性：
dir(s)
dir(list)

>**面向过程把数据和处理数据的计算全部放在一起，当功能复杂之后，就会显得很混乱，且容易产生很多重复的代码。而面向对象，把一类数据和处理这类数据的方法封装在一个类中，让程序的结构更清晰，不同的功能之间相互独立。这样更有利于进行模块化的开发方式。**
## Python对象与类
>调用类变量的方法是“对象.变量名”。你可以得到它的值，也可以改变它的值。

>注意到，类方法和我们之前定义的函数区别在于，第一个参数必须为self。而在调用类方法的时候，通过“对象.方法名()”格式进行调用，而不需要额外提供self这个参数的值。self在类方法中的值，就是你调用的这个对象本身。

### 举个栗子

```
class Vehicle:
    def __init__(self, speed):
        self.speed = speed

    def drive(self, distance):
        print 'need %f hour(s)' % (distance / self.speed)

class Bike(Vehicle):
    pass

class Car(Vehicle):
    def __init__(self, speed, fuel):
        Vehicle.__init__(self, speed)
        self.fuel = fuel

    def drive(self, distance):
        Vehicle.drive(self, distance)
        print 'need %f fuels' % (distance * self.fuel)

b = Bike(15.0)
c = Car(80.0, 0.012)
b.drive(100.0)
c.drive(100.0)
```

     解释一下代码：
    \__init__函数会在类被创建的时候自动调用，用来初始化类。它的参数，要在创建类的时候提供。于是我们通过提供一个数值来初始化speed的值。

    class定义后面的括号里表示这个类继承于哪个类。Bike(Vehicle)就是说Bike是继承自Vehicle中的子类。Vehicle中的属性和方法，Bike都会有。因为Bike不需要有额外的功能，所以用pass在类中保留空块，什么都不用写。

    Car类中，我们又重新定义了__init__和drive函数，这样会覆盖掉它继承自Vehicle的同名函数。但我们依然可以通过“Vehicle.函数名”来调用它的超类方法。以此来获得它作为Vehicle所具有的功能。注意，因为是通过类名调用方法，而不是像之前一样通过对象来调用，所以这里必须提供self的参数值。在调用超类的方法之后，我们又给Car增加了一个fuel属性，并且在drive中多输出一行信息。

    最后，我们分别创建一个速度为15的自行车对象，和一个速度为80、耗油量为0.012的汽车，然后让它们去行驶100的距离。
